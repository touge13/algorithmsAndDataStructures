Completed by: `Grudinin Mikhail Artemovich (Грудинин Михаил Артемович)`

# Профилирование доступа к памяти с помощью Valgrind
Инструмент CacheGrind Valgrind используется для анализа шаблонов доступа к памяти программы, для обнаружения проблем с управлением памятью и узких мест производительности. Результаты профилирования предоставляют информацию о поведении кэша и эффективности доступа к памяти программы.

Этот репозиторий содержит простую программу на C++, которая выполняет профилирование доступа к памяти с использованием инструмента Valgrind. Программа вычисляет сумму элементов в матрице как по строкам, так и по столбцам, и представляет результаты профилирования доступа к памяти с помощью инструмента CacheGrind Valgrind.

## Описание программы

Программа на C++ состоит из следующих основных компонентов:

1. **Генерация матрицы**: Функция `createRandomMatrix` генерирует матрицу случайных целых чисел.
2. **Вычисление суммы по строкам**: Функция `sumRows` вычисляет сумму элементов в матрице построчно.
3. **Вычисление суммы по столбцам**: Функция `sumCols` вычисляет сумму элементов в матрице по столбцам.
4. **Главная функция**: Функция `main` управляет выполнением программы. Она генерирует случайную матрицу, вычисляет суммы по строкам и столбцам, а также измеряет время выполнения каждой операции.

### Профилирование суммы элементов матрицы по столбцам и строкам

Результаты профилирования (`ColumnSums.png` и `RowSums.png` в папке `result`), предоставленные инструментом Valgrind для вычисления суммы по столбцам и по строкам показывают следующие метрики:

- **I refs**: Количество обращений к инструкциям.
- **I misses**: Количество промахов кэша инструкций.
- **LLi misses**: Количество промахов кэша последнего уровня инструкций.
- **D refs**: Количество обращений к данным.
- **D1 misses**: Количество промахов кэша данных первого уровня.
- **LLd misses**: Количество промахов кэша последнего уровня данных.

Для наглядности так же можем посмотреть на время выполнения функции `sumRows` и `sumCols`.

## Интерпретация

Различия в шаблонах доступа к памяти между вычислениями суммы по строкам и по столбцам могут привести к изменениям в использовании кэша и эффективности доступа к памяти. Профилирование этих операций помогает выявить потенциальные узкие места производительности и оптимизировать шаблоны доступа к памяти для улучшения общей производительности программы.

## Что мы получили в итоге? 
columnSums:
![Image alt](https://github.com/touge13/algorithmsAndDataStructures/raw/main//2task_memoryAccessProfiling/result/ColumnSums.png)

rowSums:
![Image alt](https://github.com/touge13/algorithmsAndDataStructures/raw/main//2task_memoryAccessProfiling/result/RowSums.png)

Мы видим, что реализация сложения по строкам работает значительно лучше, чем реализация сложения по столбцам. В первую очередь это связано с разницей в поведении кэша между двумя реализациями. 

## Почему мы получили такой результат?

**Организация памяти**: Многие архитектуры процессоров имеют линейный порядок обхода памяти, что делает обход матрицы по строкам более эффективным (это приводит к более эффективному использованию кэша и, как следствие, к более быстрой обработке данных), поскольку он соответствует этому порядку. Обход по столбцам может приводить к нелинейным переходам в памяти, т.е. доступ к данным происходит не последовательно, а через определенный шаг что может ухудшить производительность из-за затрат на переключение страниц и привести к большому количеству кэш-промахов.

## Условие задания

Профилирование доступа к памяти

Помните про кэш-попадания (hits) и кэш-промахи (misses)? А про профиляторы помните?

А если помните, то и покажите это, написав пример, который обходит (например, считает сумму элементов) матрицу «вдоль» и «поперёк», и представьте наглядно результаты профилирования.