Характеристики ПК:
- **RAM:** 16 gb 1867 MHz DDR3
- **macOS:** Monterey 12.6.7

Запустим программу на macOS и посмотрим результаты в "Мониторинге системы"
- **На чтение:** 
```
cd "../3task_memoryConsumption/" && g++ main.cpp -o main && "../3task_memoryConsumption/"main 1000 read
```
![alt text](image-read.png)

-  **На запись:** 
```
cd "../3task_memoryConsumption/" && g++ main.cpp -o main && "../3task_memoryConsumption/"main 1000 write
```
![alt text](image-write.png)

## Условие задания:
Управляемо превращаем операционую систему в тыкву
1. Выделяем много (например, вдвое больше, чем размер вашего ОЗУ) памяти при помощи malloc или new.
2. Обращаемся к памяти (каким образом — ниже, в конкретных задачах) с шагом в 4 KiB (размер страницы).
3. Чтобы превращение в тыкву было контролируемым, периодически (например, раз в 1000–5000 страниц) делаем задержку, например при помощи std::this_thread::sleep_for(std::chrono::milliseconds(delay_ms));, delay_ms предварительно посчитайте сами.
4. Наблюдаем, как в динамике растёт потребление памяти, хотя malloc или new вы вызвали один раз в начале.
Задачи (1) и (2) этого задания очень похожи. Поэтому можно (и уместно!) сделать одну программу с параметром в командной строке, который позволял бы выбрать режим первого задания (чтение) и второго (запись).

Читаем

Обращение к памяти (п. 2) сделать на чтение. Если возможно, проверьте под разными операционными системами. Чтобы компилятор точно ничего не оптимизировал, сделайте чтение в глобальную переменную, объявленную с модификатором volatile.

Пишем

Обращение к памяти (п. 2) сделать на запись. Если возможно, проверьте под разными операционными системами.